# CDPilot Chrome 扩展对接文档

## 一、项目概述

CDPilot 是一个 Chrome 扩展程序（Manifest V3），通过本地 CDP（Chrome DevTools Protocol）中继服务器将自动化平台连接到 Chrome 标签页。

### 核心功能

- 通过 WebSocket 与本地中继服务器通信
- 使用 Chrome Debugger API 附加到标签页
- 双向转发 CDP 命令和事件
- 支持多标签页会话管理

---

## 二、架构原理

### 2.1 系统架构

```
┌─────────────────┐      WebSocket       ┌─────────────────┐
│  自动化平台      │ ──────────────────▶  │  Chrome         │
│  (Client)       │   CDP 命令/事件      │  扩展 (Relay)   │
│                 │ ◀──────────────────  │                 │
└─────────────────┘                      └────────┬────────┘
                                                  │
                                        chrome.debugger API
                                                  ▼
                                         ┌─────────────────┐
                                         │  Chrome 标签页   │
                                         └─────────────────┘
```

### 2.2 组件说明

| 组件 | 作用 |
|------|------|
| **background.js** | Service Worker，核心逻辑：管理与中继服务器的 WebSocket 连接，附加/分离标签页，双向转发 CDP |
| **options.html/js** | 设置 UI，配置中继服务器端口，连接验证 |
| **manifest.json** | 扩展清单，声明权限和配置 |

---

## 三、对接方式

### 3.1 连接建立

扩展作为 WebSocket 客户端连接到中继服务器：

```
URL: ws://127.0.0.1:{port}/extension
默认端口: 18792
```

在连接前，会先发送 HEAD 请求进行预检：

```
HEAD http://127.0.0.1:{port}/ 
```

### 3.2 通信协议

所有消息均为 JSON 格式。

#### 3.2.1 中继服务器发送给扩展的消息

**CDP 命令请求：**

```json
{
  "id": 1,
  "method": "forwardCDPCommand",
  "params": {
    "method": "Runtime.evaluate",
    "params": {
      "expression": "document.querySelector('#username')"
    },
    "sessionId": "cb-tab-1"
  }
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | number | 请求唯一 ID，用于匹配响应 |
| `method` | string | 固定为 `forwardCDPCommand` |
| `params.method` | string | 实际的 CDP 方法名 |
| `params.params` | object | CDP 方法参数 |
| `params.sessionId` | string | 可选，会话 ID |

**PING（保活）：**

```json
{ "method": "ping" }
```

#### 3.2.2 扩展发送给中继服务器的消息

**CDP 命令响应：**

```json
{
  "id": 1,
  "result": { "result": { "type": "object", "objectId": "..." } }
}
```

或错误响应：

```json
{
  "id": 1,
  "error": "No attached tab for method Runtime.evaluate"
}
```

**CDP 事件转发（来自浏览器）：**

```json
{
  "method": "forwardCDPEvent",
  "params": {
    "sessionId": "cb-tab-1",
    "method": "Runtime.consoleAPICalled",
    "params": { ... }
  }
}
```

**PONG（保活响应）：**

```json
{ "method": "pong" }
```

---

## 四、CDP 命令处理

### 4.1 核心命令映射

扩展接收到 CDP 命令后，通过 `chrome.debugger.sendCommand()` 执行：

```javascript
chrome.debugger.sendCommand(debuggee, method, params)
```

其中 `debuggee = { tabId }` 或 `{ tabId, sessionId }`。

### 4.2 特殊处理的命令

| CDP 命令 | 扩展处理逻辑 |
|----------|--------------|
| `Target.createTarget` | 创建新标签页，自动附加并返回 targetId |
| `Target.closeTarget` | 关闭指定标签页 |
| `Target.activateTarget` | 激活（切换到）指定标签页 |
| `Runtime.enable` | 先执行 Runtime.disable，延迟 50ms 再启用（防止事件风暴） |

### 4.3 会话管理

- **主会话**：每个附加的标签页分配唯一会话 ID，格式为 `cb-tab-{N}`
- **子目标会话**：iframe、worker 等子目标通过 `Target.attachedToTarget` 事件自动跟踪
- **会话映射**：
  - `tabs` Map：tabId → {sessionId, targetId, state}
  - `tabBySession` Map：sessionId → tabId
  - `childSessionToTab` Map：子会话 ID → 父 tabId

### 4.4 无 sessionId 的命令

当 CDP 命令不带 `sessionId` 时，扩展选择第一个已连接的标签页执行：

```javascript
for (const [id, tab] of tabs.entries()) {
  if (tab.state === 'connected') return id
}
```

---

## 五、使用流程

### 5.1 扩展安装

1. 在 Chrome 中打开 `chrome://extensions`
2. 启用"开发者模式"
3. 点击"加载已解压的扩展程序"
4. 选择扩展程序目录

### 5.2 附加标签页

1. 打开目标网站
2. 点击扩展图标
3. 扩展建立与中继服务器的 WebSocket 连接
4. 使用 `chrome.debugger.attach()` 附加到标签页
5. 徽章显示 `ON`（橙红色），表示已连接

### 5.3 自动化操作

1. 通过 WebSocket 发送 CDP 命令
2. 扩展执行命令并返回结果
3. 监听 CDP 事件（console、network 等）

### 5.4 分离标签页

再次点击扩展图标即可断开连接。

---

## 六、状态指示

### 6.1 徽章状态

| 状态 | 徽章 | 颜色 | 含义 |
|------|------|------|------|
| 已连接 | `ON` | 橙红色 (#FF5A36) | WebSocket 已连接，标签页已附加 |
| 连接中 | `…` | 黄色 | 正在连接中继服务器或附加标签页 |
| 错误 | `!` | 红色 | 连接失败 |
| 关闭 | (无) | - | 未连接 |

### 6.2 标题提示

- 连接中：`CDPilot: connecting to local relay…`
- 已连接：`CDPilot: attached (click to detach)`
- 断开：`CDPilot: disconnected (click to re-attach)`
- 错误：`CDPilot: relay not running (open options for setup)`

---

## 七、错误处理

### 7.1 连接断开

当 WebSocket 断开时：
1. 遍历所有待处理的请求并拒绝
2. 对所有已附加的标签页执行 `chrome.debugger.detach()`
3. 清空会话映射
4. 更新徽章为连接中状态

### 7.2 自动重试

用户点击扩展图标时会自动重试连接。

### 7.3 错误传播

CDP 命令执行失败时，错误信息通过响应消息返回：

```json
{
  "id": 1,
  "error": "No attached tab for method Runtime.evaluate"
}
```

---

## 八、配置项

### 8.1 中继端口

- 配置位置：`chrome.storage.local`
- 键名：`relayPort`
- 默认值：`18792`
- 范围：1-65535

### 8.2 主机权限

仅限本机访问：
- `http://127.0.0.1/*`
- `http://localhost/*`

---

## 九、常见问题

### Q1: 如何查看扩展日志？

在 `chrome://extensions` 中找到扩展，点击"服务 worker"查看控制台输出。

### Q2: 为什么徽章显示红色感叹号？

中继服务器未运行。确保 CDP 中继服务器已启动。

### Q3: 可以同时控制多个标签页吗？

可以，每个标签页有独立的会话 ID，通过 `sessionId` 参数区分。

### Q4: 如何创建新标签页？

发送 `Target.createTarget` 命令：

```json
{
  "id": 1,
  "method": "forwardCDPCommand",
  "params": {
    "method": "Target.createTarget",
    "params": { "url": "https://example.com" }
  }
}
```

---

## 十、改进计划

### 10.1 防网站侦测改进

#### 10.1.0 扩展方案的天然优势

相比 Puppeteer/Playwright/Selenium，本扩展通过 `chrome.debugger` API 附加到**用户已有的浏览器实例**，具备以下天然反检测优势：

- **真实浏览器指纹**：使用用户真实的浏览器配置文件，Canvas/WebGL/音频指纹均为真实值
- **真实网络栈**：TCP/TLS 指纹（JA3/JA4）、HTTP/2 设置等与正常浏览器完全一致
- **真实登录状态**：可复用用户已有的 Cookie、LocalStorage、登录会话
- **无 ChromeDriver 特征**：不存在 `cdc_*`、`$chrome_async`、`$__webdriver_script_fn` 等 ChromeDriver 专有标识
- **CDP 事件 `isTrusted` 为 `true`**：通过 `Input.dispatchMouseEvent` / `Input.dispatchKeyEvent` 触发的事件是浏览器级别的，`isTrusted` 属性为 `true`，与用户真实操作一致

#### 10.1.1 仍存在的检测风险

尽管有天然优势，以下检测向量仍需关注：

| 检测方式 | 风险等级 | 说明 |
|----------|----------|------|
| `navigator.webdriver` | 中 | 部分 Chrome 版本在 debugger 附加时可能设为 `true`，需实际验证 |
| 调试信息栏 | 低 | `chrome.debugger.attach()` 会在页面顶部显示黄色横幅"此扩展正在调试此浏览器"，用户可见但页面 JS 无法读取 |
| 操作时间模式 | 高 | 自动化操作的时间间隔过于规律，与人类行为差异明显 |
| 输入事件完整性 | 高 | 真实按键有 `keydown` → `keypress` → `input` → `keyup` 完整事件链，CDP 的 `Input.dispatchKeyEvent` 需手动构造完整链 |
| 鼠标行为模式 | 高 | 点击无移动轨迹、移动速度恒定等特征易被检测 |

#### 10.1.2 改进方案

**方案 A：页面加载前注入防检测脚本（推荐）**

必须使用 `Page.addScriptToEvaluateOnNewDocument` 而非 `Runtime.evaluate`，确保脚本在页面自身 JS 执行**之前**运行，且对后续导航的新页面同样生效：

```javascript
// 在 attachTab() 成功后立即执行
await chrome.debugger.sendCommand(debuggee, 'Page.addScriptToEvaluateOnNewDocument', {
  source: `
    // 覆盖 navigator.webdriver（如果被设置了的话）
    Object.defineProperty(navigator, 'webdriver', {
      get: () => undefined,
      configurable: true
    });

    // 覆盖 navigator.plugins（返回接近真实的结构）
    Object.defineProperty(navigator, 'plugins', {
      get: () => {
        const p = {
          0: { name: 'Chrome PDF Plugin', filename: 'internal-pdf-viewer',
               description: 'Portable Document Format', length: 1 },
          1: { name: 'Chrome PDF Viewer', filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai',
               description: '', length: 1 },
          2: { name: 'Native Client', filename: 'internal-nacl-plugin',
               description: '', length: 2 },
          length: 3
        };
        p[Symbol.iterator] = function*() { for (let i = 0; i < this.length; i++) yield this[i]; };
        return p;
      }
    });

    // 覆盖 navigator.languages（使用当前浏览器真实语言，避免硬编码）
    // 注意：仅在确认默认值异常时才覆盖
  `
});
```

**方案 B：用户交互命令随机延迟**

仅对用户交互类 CDP 命令添加随机延迟，不影响内部查询命令的性能：

```javascript
// 需要添加延迟的交互类命令
const INTERACTION_METHODS = new Set([
  'Input.dispatchMouseEvent',
  'Input.dispatchKeyEvent',
  'Input.dispatchTouchEvent',
  'Input.insertText',
])

async function handleForwardCdpCommand(msg) {
  const method = String(msg?.params?.method || '').trim()

  // 仅对交互类命令添加人类化随机延迟
  if (INTERACTION_METHODS.has(method)) {
    const delay = 30 + Math.floor(Math.random() * 120) // 30-150ms
    await new Promise(r => setTimeout(r, delay))
  }

  // ... 原有处理逻辑
}
```

**方案 C：人类化鼠标轨迹模拟**

使用贝塞尔曲线生成更自然的鼠标移动路径，包含速度变化和过冲修正：

```javascript
/**
 * 生成贝塞尔曲线鼠标轨迹
 * @param {number} sx 起点 X
 * @param {number} sy 起点 Y
 * @param {number} ex 终点 X
 * @param {number} ey 终点 Y
 * @returns {{x:number, y:number, dt:number}[]} 轨迹点及每步时间间隔(ms)
 */
function generateHumanMousePath(sx, sy, ex, ey) {
  const dist = Math.hypot(ex - sx, ey - sy)
  const steps = Math.max(15, Math.floor(dist / 8) + Math.floor(Math.random() * 10))

  // 随机贝塞尔控制点（制造弧线效果）
  const cpx1 = sx + (ex - sx) * 0.25 + (Math.random() - 0.5) * dist * 0.3
  const cpy1 = sy + (ey - sy) * 0.25 + (Math.random() - 0.5) * dist * 0.3
  const cpx2 = sx + (ex - sx) * 0.75 + (Math.random() - 0.5) * dist * 0.2
  const cpy2 = sy + (ey - sy) * 0.75 + (Math.random() - 0.5) * dist * 0.2

  // 过冲：随机概率稍微超过目标再回来
  const overshoot = Math.random() < 0.3
  const ox = overshoot ? (Math.random() - 0.5) * 12 : 0
  const oy = overshoot ? (Math.random() - 0.5) * 12 : 0

  const points = []
  for (let i = 0; i <= steps; i++) {
    const t = i / steps
    // 三阶贝塞尔
    const u = 1 - t
    let x = u*u*u*sx + 3*u*u*t*cpx1 + 3*u*t*t*cpx2 + t*t*t*(ex + ox)
    let y = u*u*u*sy + 3*u*u*t*cpy1 + 3*u*t*t*cpy2 + t*t*t*(ey + oy)

    // 微小抖动
    x += (Math.random() - 0.5) * 2
    y += (Math.random() - 0.5) * 2

    // 时间间隔：开头和结尾慢，中间快
    const speed = 1 - 0.6 * Math.sin(Math.PI * t)
    const dt = Math.max(4, Math.floor(8 * speed + Math.random() * 6))

    points.push({ x: Math.round(x), y: Math.round(y), dt })
  }

  // 过冲修正：追加 2-3 个点回到真正目标
  if (overshoot) {
    for (let i = 1; i <= 2 + Math.floor(Math.random() * 2); i++) {
      const t = i / 3
      points.push({
        x: Math.round((ex + ox) + (ex - (ex + ox)) * t),
        y: Math.round((ey + oy) + (ey - (ey + oy)) * t),
        dt: 10 + Math.floor(Math.random() * 8)
      })
    }
  }

  return points
}
```

**方案 D：完整键盘事件链**

确保每次按键触发完整的事件序列，而非仅发送单个 `keyDown`：

```javascript
/**
 * 模拟真实的单个按键输入（完整事件链）
 */
async function dispatchRealKey(debuggee, key, code, keyCode) {
  const base = { key, code, windowsVirtualKeyCode: keyCode, nativeVirtualKeyCode: keyCode }
  const delay = () => new Promise(r => setTimeout(r, 5 + Math.floor(Math.random() * 20)))

  await chrome.debugger.sendCommand(debuggee, 'Input.dispatchKeyEvent',
    { type: 'keyDown', ...base })
  await delay()
  await chrome.debugger.sendCommand(debuggee, 'Input.dispatchKeyEvent',
    { type: 'char', text: key, ...base })
  await delay()
  await chrome.debugger.sendCommand(debuggee, 'Input.dispatchKeyEvent',
    { type: 'keyUp', ...base })
}
```

**方案 E：Chrome 启动参数配置**

建议用户以如下参数启动 Chrome，从根源禁用自动化标识：

```bash
chrome --disable-blink-features=AutomationControlled
```

> 注意：这是 Chrome 启动参数，不是 CDP 命令。需要用户在启动浏览器时添加，扩展本身无法修改。

#### 10.1.3 实施优先级

| 优先级 | 方案 | 改进项 | 复杂度 | 效果 |
|--------|------|--------|--------|------|
| P0 | A | `Page.addScriptToEvaluateOnNewDocument` 注入防检测脚本 | 低 | 高 |
| P0 | E | Chrome 启动参数 `--disable-blink-features=AutomationControlled` | 低（需用户配合） | 高 |
| P1 | D | 完整键盘事件链 | 低 | 高 |
| P1 | B | 交互命令随机延迟 | 低 | 中 |
| P2 | C | 贝塞尔曲线鼠标轨迹 + 过冲修正 | 中 | 中 |

### 10.2 其他改进建议

#### 10.2.1 连接稳定性

- 添加心跳检测（当前已有 ping/pong，可增强）
- 断线自动重连机制
- 指数退避重试

#### 10.2.2 安全性

- 添加 WebSocket 认证token
- 支持 HTTPS（TLS）
- 限制可访问的 IP 白名单

#### 10.2.3 功能增强

- 支持多个并发连接
- 添加日志面板
- 支持保存/恢复会话状态

---

## 附录：完整消息示例

### 标签页附加事件

```json
{
  "method": "forwardCDPEvent",
  "params": {
    "method": "Target.attachedToTarget",
    "params": {
      "sessionId": "cb-tab-1",
      "targetInfo": {
        "targetId": "C6672F9B9D5A3E1F...",
        "type": "page",
        "title": "Example Domain",
        "url": "https://example.com/",
        "attached": true
      },
      "waitingForDebugger": false
    }
  }
}
```

### 标签页分离事件

```json
{
  "method": "forwardCDPEvent",
  "params": {
    "method": "Target.detachedFromTarget",
    "params": {
      "sessionId": "cb-tab-1",
      "targetId": "C6672F9B9D5A3E1F...",
      "reason": "target_closed"
    }
  }
}
```

### Console 事件

```json
{
  "method": "forwardCDPEvent",
  "params": {
    "sessionId": "cb-tab-1",
    "method": "Runtime.consoleAPICalled",
    "params": {
      "type": "log",
      "args": [{ "type": "string", "value": "Hello from page" }],
      "executionContextId": 1,
      "timestamp": 1704067200000
    }
  }
}
```

---

*文档版本：1.1*
*最后更新：2025-02*
